export * from '../models/AddChunkToGroupData';
export * from '../models/ApiKeyDTO';
export * from '../models/AuthData';
export * from '../models/BookmarkChunks';
export * from '../models/BookmarkData';
export * from '../models/BookmarkGroupResult';
export * from '../models/ChatMessageProxy';
export * from '../models/ChunkGroup';
export * from '../models/ChunkGroupAndFile';
export * from '../models/ChunkMetadata';
export * from '../models/ChunkMetadataWithFileData';
export * from '../models/ClientDatasetConfiguration';
export * from '../models/CreateChunkData';
export * from '../models/CreateChunkGroupData';
export * from '../models/CreateDatasetRequest';
export * from '../models/CreateMessageData';
export * from '../models/CreateOrganizationData';
export * from '../models/CreateTopicData';
export * from '../models/Dataset';
export * from '../models/DatasetAndOrgWithSubAndPlan';
export * from '../models/DatasetAndUsage';
export * from '../models/DatasetDTO';
export * from '../models/DatasetGroupQuery';
export * from '../models/DatasetUsageCount';
export * from '../models/DefaultError';
export * from '../models/DeleteBookmarkPathData';
export * from '../models/DeleteDatasetRequest';
export * from '../models/DeleteGroupData';
export * from '../models/DeleteTopicData';
export * from '../models/DeleteUserApiKeyRequest';
export * from '../models/EditMessageData';
export * from '../models/Event';
export * from '../models/EventId';
export * from '../models/EventReturn';
export * from '../models/Events';
export * from '../models/FileDTO';
export * from '../models/GenerateChunksRequest';
export * from '../models/GenerateOffGroupData';
export * from '../models/GetAllBookmarksData';
export * from '../models/GetDirectPaymentLinkData';
export * from '../models/GetGroupsForChunksData';
export * from '../models/GetUserWithChunksData';
export * from '../models/GroupData';
export * from '../models/InvitationData';
export * from '../models/Message';
export * from '../models/ModelFile';
export * from '../models/Organization';
export * from '../models/OrganizationUsageCount';
export * from '../models/OrganizationWithSubAndPlan';
export * from '../models/RecommendChunksRequest';
export * from '../models/RegenerateMessageData';
export * from '../models/ReturnCreatedChunk';
export * from '../models/ScoreChunkDTO';
export * from '../models/SearchChunkData';
export * from '../models/SearchChunkDataTimeRangeInner';
export * from '../models/SearchChunkDataWeightsInner';
export * from '../models/SearchChunkQueryResponseBody';
export * from '../models/SearchGroupsData';
export * from '../models/SearchGroupsResult';
export * from '../models/SetUserApiKeyRequest';
export * from '../models/SetUserApiKeyResponse';
export * from '../models/SlimGroup';
export * from '../models/SlimUser';
export * from '../models/StripePlan';
export * from '../models/StripeSubscription';
export * from '../models/SuggestedQueriesRequest';
export * from '../models/SuggestedQueriesResponse';
export * from '../models/Topic';
export * from '../models/UpdateChunkByTrackingIdData';
export * from '../models/UpdateChunkData';
export * from '../models/UpdateChunkGroupData';
export * from '../models/UpdateDatasetRequest';
export * from '../models/UpdateOrganizationData';
export * from '../models/UpdateSubscriptionData';
export * from '../models/UpdateTopicData';
export * from '../models/UpdateUserData';
export * from '../models/UploadFileData';
export * from '../models/UploadFileResult';
export * from '../models/UserDTO';
export * from '../models/UserDTOWithChunks';
export * from '../models/UserOrganization';
export * from '../models/UserRole';

import { AddChunkToGroupData } from '../models/AddChunkToGroupData';
import { ApiKeyDTO } from '../models/ApiKeyDTO';
import { AuthData } from '../models/AuthData';
import { BookmarkChunks } from '../models/BookmarkChunks';
import { BookmarkData } from '../models/BookmarkData';
import { BookmarkGroupResult } from '../models/BookmarkGroupResult';
import { ChatMessageProxy } from '../models/ChatMessageProxy';
import { ChunkGroup } from '../models/ChunkGroup';
import { ChunkGroupAndFile } from '../models/ChunkGroupAndFile';
import { ChunkMetadata } from '../models/ChunkMetadata';
import { ChunkMetadataWithFileData } from '../models/ChunkMetadataWithFileData';
import { ClientDatasetConfiguration } from '../models/ClientDatasetConfiguration';
import { CreateChunkData } from '../models/CreateChunkData';
import { CreateChunkGroupData } from '../models/CreateChunkGroupData';
import { CreateDatasetRequest } from '../models/CreateDatasetRequest';
import { CreateMessageData } from '../models/CreateMessageData';
import { CreateOrganizationData } from '../models/CreateOrganizationData';
import { CreateTopicData } from '../models/CreateTopicData';
import { Dataset } from '../models/Dataset';
import { DatasetAndOrgWithSubAndPlan } from '../models/DatasetAndOrgWithSubAndPlan';
import { DatasetAndUsage } from '../models/DatasetAndUsage';
import { DatasetDTO } from '../models/DatasetDTO';
import { DatasetGroupQuery } from '../models/DatasetGroupQuery';
import { DatasetUsageCount } from '../models/DatasetUsageCount';
import { DefaultError } from '../models/DefaultError';
import { DeleteBookmarkPathData } from '../models/DeleteBookmarkPathData';
import { DeleteDatasetRequest } from '../models/DeleteDatasetRequest';
import { DeleteGroupData } from '../models/DeleteGroupData';
import { DeleteTopicData } from '../models/DeleteTopicData';
import { DeleteUserApiKeyRequest } from '../models/DeleteUserApiKeyRequest';
import { EditMessageData } from '../models/EditMessageData';
import { Event } from '../models/Event';
import { EventId } from '../models/EventId';
import { EventReturn } from '../models/EventReturn';
import { Events } from '../models/Events';
import { FileDTO } from '../models/FileDTO';
import { GenerateChunksRequest } from '../models/GenerateChunksRequest';
import { GenerateOffGroupData } from '../models/GenerateOffGroupData';
import { GetAllBookmarksData } from '../models/GetAllBookmarksData';
import { GetDirectPaymentLinkData } from '../models/GetDirectPaymentLinkData';
import { GetGroupsForChunksData } from '../models/GetGroupsForChunksData';
import { GetUserWithChunksData } from '../models/GetUserWithChunksData';
import { GroupData } from '../models/GroupData';
import { InvitationData } from '../models/InvitationData';
import { Message } from '../models/Message';
import { ModelFile } from '../models/ModelFile';
import { Organization } from '../models/Organization';
import { OrganizationUsageCount } from '../models/OrganizationUsageCount';
import { OrganizationWithSubAndPlan } from '../models/OrganizationWithSubAndPlan';
import { RecommendChunksRequest } from '../models/RecommendChunksRequest';
import { RegenerateMessageData } from '../models/RegenerateMessageData';
import { ReturnCreatedChunk } from '../models/ReturnCreatedChunk';
import { ScoreChunkDTO } from '../models/ScoreChunkDTO';
import { SearchChunkData } from '../models/SearchChunkData';
import { SearchChunkDataTimeRangeInner } from '../models/SearchChunkDataTimeRangeInner';
import { SearchChunkDataWeightsInner } from '../models/SearchChunkDataWeightsInner';
import { SearchChunkQueryResponseBody } from '../models/SearchChunkQueryResponseBody';
import { SearchGroupsData } from '../models/SearchGroupsData';
import { SearchGroupsResult } from '../models/SearchGroupsResult';
import { SetUserApiKeyRequest } from '../models/SetUserApiKeyRequest';
import { SetUserApiKeyResponse } from '../models/SetUserApiKeyResponse';
import { SlimGroup } from '../models/SlimGroup';
import { SlimUser } from '../models/SlimUser';
import { StripePlan } from '../models/StripePlan';
import { StripeSubscription } from '../models/StripeSubscription';
import { SuggestedQueriesRequest } from '../models/SuggestedQueriesRequest';
import { SuggestedQueriesResponse } from '../models/SuggestedQueriesResponse';
import { Topic } from '../models/Topic';
import { UpdateChunkByTrackingIdData } from '../models/UpdateChunkByTrackingIdData';
import { UpdateChunkData } from '../models/UpdateChunkData';
import { UpdateChunkGroupData } from '../models/UpdateChunkGroupData';
import { UpdateDatasetRequest } from '../models/UpdateDatasetRequest';
import { UpdateOrganizationData } from '../models/UpdateOrganizationData';
import { UpdateSubscriptionData } from '../models/UpdateSubscriptionData';
import { UpdateTopicData } from '../models/UpdateTopicData';
import { UpdateUserData } from '../models/UpdateUserData';
import { UploadFileData } from '../models/UploadFileData';
import { UploadFileResult } from '../models/UploadFileResult';
import { UserDTO } from '../models/UserDTO';
import { UserDTOWithChunks } from '../models/UserDTOWithChunks';
import { UserOrganization } from '../models/UserOrganization';
import { UserRole } from '../models/UserRole';

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

let enumsMap: Set<string> = new Set<string>([
    "UserRole",
]);

let typeMap: {[index: string]: any} = {
    "AddChunkToGroupData": AddChunkToGroupData,
    "ApiKeyDTO": ApiKeyDTO,
    "AuthData": AuthData,
    "BookmarkChunks": BookmarkChunks,
    "BookmarkData": BookmarkData,
    "BookmarkGroupResult": BookmarkGroupResult,
    "ChatMessageProxy": ChatMessageProxy,
    "ChunkGroup": ChunkGroup,
    "ChunkGroupAndFile": ChunkGroupAndFile,
    "ChunkMetadata": ChunkMetadata,
    "ChunkMetadataWithFileData": ChunkMetadataWithFileData,
    "ClientDatasetConfiguration": ClientDatasetConfiguration,
    "CreateChunkData": CreateChunkData,
    "CreateChunkGroupData": CreateChunkGroupData,
    "CreateDatasetRequest": CreateDatasetRequest,
    "CreateMessageData": CreateMessageData,
    "CreateOrganizationData": CreateOrganizationData,
    "CreateTopicData": CreateTopicData,
    "Dataset": Dataset,
    "DatasetAndOrgWithSubAndPlan": DatasetAndOrgWithSubAndPlan,
    "DatasetAndUsage": DatasetAndUsage,
    "DatasetDTO": DatasetDTO,
    "DatasetGroupQuery": DatasetGroupQuery,
    "DatasetUsageCount": DatasetUsageCount,
    "DefaultError": DefaultError,
    "DeleteBookmarkPathData": DeleteBookmarkPathData,
    "DeleteDatasetRequest": DeleteDatasetRequest,
    "DeleteGroupData": DeleteGroupData,
    "DeleteTopicData": DeleteTopicData,
    "DeleteUserApiKeyRequest": DeleteUserApiKeyRequest,
    "EditMessageData": EditMessageData,
    "Event": Event,
    "EventId": EventId,
    "EventReturn": EventReturn,
    "Events": Events,
    "FileDTO": FileDTO,
    "GenerateChunksRequest": GenerateChunksRequest,
    "GenerateOffGroupData": GenerateOffGroupData,
    "GetAllBookmarksData": GetAllBookmarksData,
    "GetDirectPaymentLinkData": GetDirectPaymentLinkData,
    "GetGroupsForChunksData": GetGroupsForChunksData,
    "GetUserWithChunksData": GetUserWithChunksData,
    "GroupData": GroupData,
    "InvitationData": InvitationData,
    "Message": Message,
    "ModelFile": ModelFile,
    "Organization": Organization,
    "OrganizationUsageCount": OrganizationUsageCount,
    "OrganizationWithSubAndPlan": OrganizationWithSubAndPlan,
    "RecommendChunksRequest": RecommendChunksRequest,
    "RegenerateMessageData": RegenerateMessageData,
    "ReturnCreatedChunk": ReturnCreatedChunk,
    "ScoreChunkDTO": ScoreChunkDTO,
    "SearchChunkData": SearchChunkData,
    "SearchChunkDataTimeRangeInner": SearchChunkDataTimeRangeInner,
    "SearchChunkDataWeightsInner": SearchChunkDataWeightsInner,
    "SearchChunkQueryResponseBody": SearchChunkQueryResponseBody,
    "SearchGroupsData": SearchGroupsData,
    "SearchGroupsResult": SearchGroupsResult,
    "SetUserApiKeyRequest": SetUserApiKeyRequest,
    "SetUserApiKeyResponse": SetUserApiKeyResponse,
    "SlimGroup": SlimGroup,
    "SlimUser": SlimUser,
    "StripePlan": StripePlan,
    "StripeSubscription": StripeSubscription,
    "SuggestedQueriesRequest": SuggestedQueriesRequest,
    "SuggestedQueriesResponse": SuggestedQueriesResponse,
    "Topic": Topic,
    "UpdateChunkByTrackingIdData": UpdateChunkByTrackingIdData,
    "UpdateChunkData": UpdateChunkData,
    "UpdateChunkGroupData": UpdateChunkGroupData,
    "UpdateDatasetRequest": UpdateDatasetRequest,
    "UpdateOrganizationData": UpdateOrganizationData,
    "UpdateSubscriptionData": UpdateSubscriptionData,
    "UpdateTopicData": UpdateTopicData,
    "UpdateUserData": UpdateUserData,
    "UploadFileData": UploadFileData,
    "UploadFileResult": UploadFileResult,
    "UserDTO": UserDTO,
    "UserDTOWithChunks": UserDTOWithChunks,
    "UserOrganization": UserOrganization,
}

type MimeTypeDescriptor = {
    type: string;
    subtype: string;
    subtypeTokens: string[];
};

/**
 * Every mime-type consists of a type, subtype, and optional parameters.
 * The subtype can be composite, including information about the content format.
 * For example: `application/json-patch+json`, `application/merge-patch+json`.
 *
 * This helper transforms a string mime-type into an internal representation.
 * This simplifies the implementation of predicates that in turn define common rules for parsing or stringifying
 * the payload.
 */
const parseMimeType = (mimeType: string): MimeTypeDescriptor => {
    const [type, subtype] = mimeType.split('/');
    return {
        type,
        subtype,
        subtypeTokens: subtype.split('+'),
    };
};

type MimeTypePredicate = (mimeType: string) => boolean;

// This factory creates a predicate function that checks a string mime-type against defined rules.
const mimeTypePredicateFactory = (predicate: (descriptor: MimeTypeDescriptor) => boolean): MimeTypePredicate => (mimeType) => predicate(parseMimeType(mimeType));

// Use this factory when you need to define a simple predicate based only on type and, if applicable, subtype.
const mimeTypeSimplePredicateFactory = (type: string, subtype?: string): MimeTypePredicate => mimeTypePredicateFactory((descriptor) => {
    if (descriptor.type !== type) return false;
    if (subtype != null && descriptor.subtype !== subtype) return false;
    return true;
});

// Creating a set of named predicates that will help us determine how to handle different mime-types
const isTextLikeMimeType = mimeTypeSimplePredicateFactory('text');
const isJsonMimeType = mimeTypeSimplePredicateFactory('application', 'json');
const isJsonLikeMimeType = mimeTypePredicateFactory((descriptor) => descriptor.type === 'application' && descriptor.subtypeTokens.some((item) => item === 'json'));
const isOctetStreamMimeType = mimeTypeSimplePredicateFactory('application', 'octet-stream');
const isFormUrlencodedMimeType = mimeTypeSimplePredicateFactory('application', 'x-www-form-urlencoded');

// Defining a list of mime-types in the order of prioritization for handling.
const supportedMimeTypePredicatesWithPriority: MimeTypePredicate[] = [
    isJsonMimeType,
    isJsonLikeMimeType,
    isTextLikeMimeType,
    isOctetStreamMimeType,
    isFormUrlencodedMimeType,
];

export class ObjectSerializer {
    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap.has(expectedType)) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    if(typeMap[discriminatorType]){
                        return discriminatorType; // use the type given in the discriminator
                    } else {
                        return expectedType; // discriminator did not map to a type
                    }
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string, format: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let date of data) {
                transformedData.push(ObjectSerializer.serialize(date, subType, format));
            }
            return transformedData;
        } else if (type === "Date") {
            if (format == "date") {
                let month = data.getMonth()+1
                month = month < 10 ? "0" + month.toString() : month.toString()
                let day = data.getDate();
                day = day < 10 ? "0" + day.toString() : day.toString();

                return data.getFullYear() + "-" + month + "-" + day;
            } else {
                return data.toISOString();
            }
        } else {
            if (enumsMap.has(type)) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // Get the actual type of this object
            type = this.findCorrectType(data, type);

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let attributeType of attributeTypes) {
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string, format: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let date of data) {
                transformedData.push(ObjectSerializer.deserialize(date, subType, format));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap.has(type)) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let attributeType of attributeTypes) {
                let value = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
                if (value !== undefined) {
                    instance[attributeType.name] = value;
                }
            }
            return instance;
        }
    }


    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    public static normalizeMediaType(mediaType: string | undefined): string | undefined {
        if (mediaType === undefined) {
            return undefined;
        }
        return mediaType.split(";")[0].trim().toLowerCase();
    }

    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    public static getPreferredMediaType(mediaTypes: Array<string>): string {
        /** According to OAS 3 we should default to json */
        if (mediaTypes.length === 0) {
            return "application/json";
        }

        const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);

        for (const predicate of supportedMimeTypePredicatesWithPriority) {
            for (const mediaType of normalMediaTypes) {
                if (mediaType != null && predicate(mediaType)) {
                    return mediaType;
                }
            }
        }

        throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
    }

    /**
     * Convert data to a string according the given media type
     */
    public static stringify(data: any, mediaType: string): string {
        if (isTextLikeMimeType(mediaType)) {
            return String(data);
        }

        if (isJsonLikeMimeType(mediaType)) {
            return JSON.stringify(data);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.stringify.");
    }

    /**
     * Parse data from a string according to the given media type
     */
    public static parse(rawData: string, mediaType: string | undefined) {
        if (mediaType === undefined) {
            throw new Error("Cannot parse content. No Content-Type defined.");
        }

        if (isTextLikeMimeType(mediaType)) {
            return rawData;
        }

        if (isJsonLikeMimeType(mediaType)) {
            return JSON.parse(rawData);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.parse.");
    }
}
